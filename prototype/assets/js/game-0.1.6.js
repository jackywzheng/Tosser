// phaser game configurationlet config = {    type: Phaser.AUTO,    width: 800,    height: 600,    physics: {        default: 'arcade',        arcade: {            gravity: {                y: 0            },            debug: true        }    },    scene: {        preload: preload,        create: create,        update: update    }};// initialize phaser gamelet game = new Phaser.Game(config);console.log(game);// constantsconst projectileXVelocityMultiplier = 300;const projectileYVelocity = -300;// initialise queuelet queuePosition = 0;let projectileQueue = [    {        name: 'paper',        image: 'paper'    },    {        name: 'banana',        image: 'banana'    }];// projectile vector mathlet betweenPoints = Phaser.Math.Angle.BetweenPoints;// preload phaser gamefunction preload() {    // load image assets    this.load.image('background', 'assets/img/background.jpg');    this.load.image('bin', 'assets/img/bin.jpg');    this.load.image('paper', 'assets/img/paper.png');    this.load.image('banana', 'assets/img/banana-sprite.png');}// create phaser gamefunction create() {    // create background    let background = this.add.image(400, 300, 'background');    // crete bin    let bin = this.add.image(400, 100, 'bin');    bin.displayWidth = 150;    bin.displayHeight = 150;    // create projectile    let paper = createProjectileSprite(this, bin);}// update phaser gamefunction update() {}// create create sprite from queuefunction createProjectileSprite(game) {    // create new projectile object    let newProjectile = game.physics.add.sprite(400, 550, 'paper');    newProjectile.displayWidth = 50;    newProjectile.displayHeight = 50;    newProjectile.setInteractive();    // add physics to sprite    addSpritePhysics(game, newProjectile);    return newProjectile;}// add physics to sprite objectfunction addSpritePhysics(game, projectile, bin) {    // add listener for pointer down on the object    projectile.on('pointerdown', function (pointerDown) {        // position of pointer down        let downPointPosition = new Phaser.Geom.Point(pointerDown.x, pointerDown.y);        if (projectile.getBounds().contains(pointerDown.downX, pointerDown.downY)) {            // add listener for pointer up if the pointer down was on the object            game.input.on('pointerup', function (pointerUp) {                // position of pointer up                let upPointerPosition = new Phaser.Geom.Point(pointerUp.x, pointerUp.y);                // velocity calculations                let angle = Phaser.Math.Angle.BetweenPoints(downPointPosition, upPointerPosition);                let xVelocity = upPointerPosition.x - downPointPosition.x;                let yVelocity = upPointerPosition.y - downPointPosition.y;                let projectileVelocity = new Phaser.Math.Vector2(xVelocity, yVelocity);                projectileVelocity.normalize();                console.log(projectileVelocity);                console.log("Angle -> " + angle);                // apply velocity                projectile.enableBody(true, projectile.x, projectile.y, true, true);                projectile.setVelocity(projectileVelocity.x * projectileXVelocityMultiplier, projectileYVelocity);                // remove pointer up listener after processing                // todo: missing arguments for removeListener                game.input.removeListener('pointerup');            }, game);        }        // create overlap listener for sprite + bin    }, game);    detectProjectileBinOverlap(projectile, bin, game);}function detectProjectileBinOverlap(projectile, bin, game) {    game.physics.add.overlap(projectile, bin, projectileOverlapBin, null, game);    console.log(game);}function projectileOverlapBin() {    console.log("worked");}